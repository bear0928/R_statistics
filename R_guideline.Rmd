---
title: "R Guideline"
author: "TA Hsiung"
date: "2024-07-10"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Getting Started with R

R 是一款專為統計分析和數據視覺化設計的強大且免費的軟件環境。<br>
它融合了統計包的便利性和編程的靈活性，廣泛應用於數據分析、機器學習和科學研究。<br>
R 提供了豐富的統計和圖形功能，使得用戶能夠進行複雜的數據操作和高質量的圖形輸出。<br>


## 1. 安裝與R語言入門

教學檔案.pdf [下載點](https://drive.google.com/file/d/19KnlivREtSyZJWFhNvTUQkHfPrDvVnBn/view?usp=sharing)

## 2. 設定工作目錄 (working directory)

```{r, wd}
# 獲取當前工作目錄，使用函數 getwd()
getwd()

# 設置工作目錄，使用函數 setwd()
setwd("/Users/bear/dev/Python")
getwd()

```





# Chapter 2

Chapter 2 - R markdown檔案 [下載點](https://drive.google.com/file/d/1JJa5F2DwkJ8Szw5mhVzfSns4wEOGj2JE/view?usp=sharing)

## 1. 安裝並載入套件&讀檔

```{r CRAN, include=FALSE}
options(repos = c(CRAN = "https://cran.r-project.org"))
```


```{r install_packages, message=FALSE, warning=FALSE, results='hide'}
# 安裝openxlsx套件--套件只要安裝過一次即可
# install.packages("openxlsx")

# 載入套件
library(openxlsx)
```


### 將xlsx檔案讀入為dataframe

Chapter2.xlsx [下載點](https://docs.google.com/spreadsheets/d/16s-_ftmfIGnKEoCx1QC34F1N7DUQSILk/edit?usp=sharing&ouid=110553448349846752071&rtpof=true&sd=true)

```{r read_file}
# 讀取檔案
file_path <- "/Users/bear/dev/R/Statistics/Data Files/Chapter2.xlsx" # 更改成您要讀取之xlsx的路徑
sheet_name_1 <- "Marital_Status" #這裡輸入您要讀取的sheet的名稱
sheet_name_2 <- "MV_Houses" #這裡輸入您要讀取的sheet的名稱

# 使用read.xlsx函數讀取指定的工作表
marital.status.df <- read.xlsx(file_path, sheet = sheet_name_1)
mv.houses.df <- read.xlsx(file_path, sheet = sheet_name_2)
```

```{r print_data}
# 顯示讀取的數據
print(marital.status.df)
print(mv.houses.df)
```


## 2. 繪製圓餅圖(Pie Chart)

### 繪製1960年婚姻狀態圓餅圖
```{r, pie_chart}
# R語言的基本繪圖功能 -- pie()函數
pie(marital.status.df[, "1960"], # 選擇使用marital.status.df中1960年的資料繪製圓餅圖
    labels = marital.status.df[, "Marital.Status"], # 選擇用來分類的feature為婚姻狀況(Marital.Status)
    main = "Marital Status, 1960") # 設定圓餅圖的標題
```

```{r, pie_chart_ggplot2}
# ggplot2套件繪圖功能
# 載入ggplot2套件
library(ggplot2)

# 設置圓餅圖的顏色
colors <- c("#EAD7D7", "#C4A0A0", "#A69291", "#6B6363")

# 使用 ggplot() 函數，設置資料來源為 marital.status.df，aes() 函數設置x與y變數，以及對應到不同顏色變量的屬性
ggplot(marital.status.df, aes(x = "", y = `1960`, fill = `Marital.Status`)) +
  # 使用 geom_bar() 函數繪製長條圖，設置寬度為1，stat = "identity" 表示使用資料的實際值
  geom_bar(width = 1, stat = "identity") +
  # 使用 coord_polar() 函數將長條圖轉換為圓餅圖，theta = "y" 表示以 y 軸為角度
  coord_polar(theta = "y") +
  # 使用 scale_fill_manual() 函數設置填充顏色
  scale_fill_manual(values = colors) +
  # 設值圓餅圖標題
  labs(title = "Marital Status, 1960") +
  # 將背景設定為空白
  theme_void() +
  # 將圖例設置在右側
  theme(legend.position = "right")


```

### 將兩個圓餅圖放在一起比較！
```{r, pie_chart_advance}
library(ggplot2)
library(gridExtra)

# 設置圓餅圖的顏色
colors <- c("#F0C9C9", "#E5A5A5", "#D18E8E", "#8C7E7E")

# 繪製1960年的圓餅圖
plot_1960 <- ggplot(marital.status.df, aes(x = "", y = `1960`, fill = `Marital.Status`)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = colors) +
  labs(title = "Marital Status, 1960") +
  theme_void() +
  theme(legend.position = "right")

# 繪製2010年的圓餅圖
plot_2010 <- ggplot(marital.status.df, aes(x = "", y = `2010`, fill = `Marital.Status`)) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar(theta = "y") +
  scale_fill_manual(values = colors) +
  labs(title = "Marital Status, 2010") +
  theme_void() +
  theme(legend.position = "right")

# 使用 gridExtra 將兩個圓餅圖合再一起
combined_plot <- grid.arrange(plot_1960, plot_2010, ncol = 2)

```

## 3. 繪製長條圖(Bar Chart)

```{r, bar_chart}
# R語言的基本繪圖功能 -- barplot()
# 取出我們感興趣的第二列和第三列數據，使用as.matrix()函數將這些數值保存為列形式，然後使用轉置函數t()將列轉換為行
marital.status.matrix.t <- t(as.matrix(marital.status.df[, 2:3]))

# 顯示轉置後的數據
print(marital.status.matrix.t)

# 使用colnames()函數為轉置後的矩陣中的每一列命名列名
colnames(marital.status.matrix.t) <- marital.status.df[, 'Marital.Status']

# 這樣轉置後的矩陣就有列名了
print(marital.status.matrix.t)

# 使用 barplot() 函數創建一個長條圖
barplot(marital.status.matrix.t, # 傳入的數據
        beside = TRUE, # 指定條形圖是並列顯示，而不是堆疊顯示
        ylab = 'Proportions', # 設定y軸標籤
        col = c('slateblue4', 'red3')) # 設定不同類別的顏色，此處共設定兩種顏色
abline(h=0) # 在當前的圖形中添加一條水平於 y=0 的直線（也就是x軸）
legend("topright", c("1960","2010"), pch=15, col=c("slateblue4","red3")) # 設置圖例位置、標籤、字體大小與顏色
```

## 4. 繪製直方圖(Histogram)


```{r, histogram}
# R語言的基本繪圖功能 -- hist() 函數
hist(mv.houses.df[, "House.Price"], # 使用mv.houses.df 的 House.Price 欄位作為輸入資料
     breaks = 5, # 指定直方圖中的分組數量
     xlab = "House Prices (in $1000s)", # 設置 x 軸的標籤
     main = NULL) # 設置圖表的標題，這裡並無設置，因此為NULL
```

## 5. 繪製次數多邊圖(Polygon)

```{r, polygon}
# 輸入中點向量和相對頻率數據
midpoint <- seq(from = 250, to = 850, by = 100)
relative.frequency <- c(0, 0.11, 0.31, 0.39, 0.14, 0.06, 0)

# R語言的基本繪圖功能 -- plot()
plot(relative.frequency ~ midpoint, # 將 relative.frequency（y 軸）繪製為與 midpoint（x 軸）的函數關係
     ylab = "Relative Frequency",  # 設置了 y 軸的標籤為 "Relative Frequency"
     xlab = "House Prices (in $1000s)") # 設置 x 軸的標籤為 "House Prices (in $1000s)"
lines(relative.frequency ~ midpoint) # 將繪製的點進行連線
```

## 6. 繪製累積百分比曲線圖(Ogive)

```{r}
# 輸入房屋價格區間與相對頻率有關的資料
midpoint <- seq(from = 300, to = 800, by = 100)
relative.frequency <- c(0, 0.11, 0.42, 0.81, 0.95, 1) # 定義成一個向量

# R語言的基本繪圖功能 -- plot()
plot(relative.frequency ~ midpoint, # 將 relative.frequency（y 軸）繪製為與 midpoint（x 軸）的函數關係
     ylab = "Relative Frequency", # 設置了 y 軸的標籤為 "Relative Frequency"
     xlab = "House Prices (in $1000s)") # 設置 x 軸的標籤為 "House Prices (in $1000s)"
lines(relative.frequency ~ midpoint)  # 將繪製的點進行連線
```

## 7. 繪製散佈圖(Scatterplot)

```{r, scatterplot}
# 輸入並且設定資料
edinc.matrix <- rbind(c(3,45),c(4,56), c(6,85), c(2,35),
                      c(5,55),c(4,48), c(8,100), c(0,38))
colnames(edinc.matrix) <- c("education", "income")
edinc.matrix

# R語言的基本繪圖功能 -- plot()
plot(edinc.matrix, ylab = "Income", xlab = "Education")
```


# Chapter 3

Chapter 3 - R markdown檔案 [下載點](https://drive.google.com/file/d/1JlP8sGDQN3GHUixnh8TqjGmZJ-r2wrhZ/view?usp=share_link)

**在這個章節，我們使用的資料集是「Fund_Returns」:**
Fund_Returns.xlsx [下載點](https://docs.google.com/spreadsheets/d/1rKbstviJN1Rppem3h56P1kraNQOcpxC-/edit?usp=sharing&ouid=110553448349846752071&rtpof=true&sd=true)

## 1. 載入套件&讀檔
```{r, read_file2}
# 載入套件
library(openxlsx)

# 讀取檔案
file_path <- "/Users/bear/dev/R/Statistics/Data Files/Fund_Returns.xlsx" # 更改成您要讀取之xlsx的路徑

# 使用read.xlsx函數讀取
fund.returns.df <- read.xlsx(file_path)

# 印出資料集
print(fund.returns.df)
```

## 2. 獲取基本數據摘要

```{r summary}
# 使用 fund.returns.df 展示如何獲取一個dataframe的數據統計摘要
(summary(fund.returns.df))
```

```{r mean}
# 此外，R 具有許多可以獨立生成這些測量值的函數。
# 例如，函數 mean()、median()、min()、max()、sd() 和 var() 分別提供均值、中位數、最小值、最大值、標準差和方差。
# 假設想找到 Fund_Return 數據中 Metals 基金的均值，可以輸入以下命令：
mean(fund.returns.df[, 'Metals'])
```

## 3. 建立箱型圖(Box Plot)


```{r box plot fund.returns1}
# 使用 boxplot() 函數與fund.returns.df數據框來創建 Metals 的水平箱型圖
# 方法一
boxplot(fund.returns.df[, 'Metals'], horizontal = TRUE)
```

```{r box plot fund.returns2}
# 方法二
boxplot(fund.returns.df$Metals, # 選擇數據
        horizontal = TRUE, # 生成水平箱型圖
        main = NULL, # 設置圖表的標題
        xlab = NULL) # 設置 X 軸的標籤
```

## 4. 計算共變異數和相關係數

### 計算共變異數(Covariance)
```{r Covariance}
# 計算共變異數矩陣
cov_matrix <- cov(fund.returns.df)
print(cov_matrix)
```

### 計算相關係數(Correlation Coefficients)

```{r Correlation Coefficients}
# 計算相關矩陣
cor_matrix <- cor(fund.returns.df)
print(cor_matrix)
```

# Chapter 5

Chapter 5 - R markdown檔案 [下載點](https://drive.google.com/file/d/1sEUBeMeWbyOTpv6esoBX8NVxV3d-2lCX/view?usp=share_link)

## 1.二項分布
**使用 dbinom(x, n, p) 函數來計算二項隨機變數 X 取特定值 x 的機率** <br>
**其中 x 是成功次數，n 是試驗次數，p 是成功的機率**
```{r dbinom(x, n, p)}
# 課本範例5.9a
# 因為 X 是一個二項隨機變數，且 n = 100，p = 0.047，我們可以通過輸入以下程式碼來找到 P(X = 5):
dbinom(5, 100, 0.047)
```

## 2.卜瓦松分布
**使用 dpois(x, μ) 函數來計算泊松隨機變數 X 取特定值 x 的機率**<br>
**其中 x 是在某個區間內的成功次數，μ 是該區間內的平均值**
```{r ppois(x, μ)}
# 課本範例5.11a
# 因為 X 是一個泊松隨機變數，且 μ = 114，我們可以通過輸入以下程式碼來找到 P(X ≤ 100):
ppois(100, 114)
```

## 3.超幾何分布
**使用 dhyper(x, S, N − S, n) 函數來計算超幾何隨機變數 X 取特定值 x 的機率**<br>
**其中 x 是樣本中的成功次數，S 是總體中的成功次數，N 是總體大小（所以 N − S 是失敗次數），n 是樣本大小**
```{r dhyper(x, S, N − S, n)}
# 課本範例5.12a
# 因為 X 是一個超幾何隨機變數，且 S = 2，N = 20（所以 20 − 2 = 18），以及 n = 5，我們可以通過輸入以下程式碼來找到 P(X = 1)：
dhyper(1, 2, 18, 5)
```


# Chapter 6

## 1.均勻分布
**使用 punif(x, a, b, lower.tail = FALSE or TRUE) 函數來計算連續均勻隨機變數 X 在區間 [a, b] 內取某個範圍值的機率**<br>
**其中 x 是我們希望評估機率的值，a 是連續均勻分布的下界，b 是上界**<br>
**對於函數中的最後一個參數，如果我們輸入 lower.tail = FALSE，則 R 返回 P(X>x)；如果輸入 lower.tail = TRUE，則 R 返回 P(X≤x)**
```{r punif(x, a, b)}
# 課本範例6.1b
# 因為 X 是一個連續均勻隨機變數，且 a = 2500 和 b = 5000，我們可以通過輸入以下程式碼來找到 P(X>4000)：
punif(4000, 2500, 5000, lower.tail = FALSE)
```

## 2.常態分佈
**使用 pnorm(x, μ, σ, lower.tail = FALSE or TRUE) 函數來計算常態隨機變數 X 小於或等於 x 或大於 x 的機率**<br>
**其中 x 是我們希望評估機率的值，μ 是總體平均數，σ 是總體標準差**<br>
**對於函數中的最後一個參數，如果輸入 lower.tail = FALSE，則 R 返回 P(X>x)；如果輸入 lower.tail = TRUE，則 R 返回 P(X≤x)**

```{r pnorm}
# 課本範例6.8a
# 因為X 是一個正態隨機變數，且 μ = 12 和 σ = 3.2，我們可以通過輸入以下程式碼來找到 P(X>20)
pnorm(20, 12, 3.2, lower.tail = FALSE)
```

### 逆轉換
**使用 qnorm(probability, μ, σ) 函數來找到對應於給定累積正態機率的特定 x 值**<br>
**其中 probability 是給定的累積機率，μ 是總體平均數，σ 是總體標準差**
```{r inverse}
# 課本範例6.8c
# 希望找到 x 使得 P(X≤x)=0.90，且 μ = 12 和 σ = 3.2，我們可以通過輸入以下程式碼來找到該 x 值
qnorm(0.90, 12, 3.2)
```

## 3.指數分佈
**使用 pexp(x, λ, lower.tail = FALSE or TRUE) 函數來計算指數隨機變數 X 小於或等於 x 或大於 x 的機率**<br>
**其中 x 是我們希望評估機率的值，λ 是速率參數**<br>
**對於函數中的最後一個參數如果我們輸入 lower.tail = FALSE，則 R 返回 P(X>x)；如果輸入 lower.tail = TRUE，則 R 返回 P(X≤x)**
```{r pexp}
# 課本範例6.9b
# 因為 X 是一個指數隨機變數，且 λ = 1/25，我們可以通過輸入以下程式碼來找到 P(X>60)
pexp(60, rate = 1/25, lower.tail = FALSE)
```

## 4.對數常態分布
**使用 plnorm(y, μ, σ) 函數來計算對數常態隨機變數 Y 小於或等於 y 的機率**<br>
**其中 y 是我們希望評估機率的值，μ 是潛在正態分布的平均數，σ 是潛在正態分布的標準差**
```{r plnorm}
# 課本範例6.11a
# 因為 Y 是一個對數正態隨機變數，且 μ = 5 和 σ = 1.2，我們可以通過輸入以下程式碼來找到 P(Y≤200)
plnorm(200, 5, 1.2)
```

### 逆轉換
**使用 qlnorm(probability, μ, σ) 函數來找到對應於給定累積對數正態機率的特定 y 值**<br>
**其中 probability 是給定的累積機率，μ 是潛在正態分布的平均數，σ 是潛在正態分布的標準差**
```{r qlnorm}
# 課本範例6.11b
# 因為我們希望找到 y 使得 P(Y≤y)=0.90，且 μ = 5 和 σ = 1.2，我們可以通過輸入以下程式碼來找到該 y 值
qlnorm(0.90, 5, 1.2)
```

# Chapter 7
Chapter7.xlsx [下載點](https://docs.google.com/spreadsheets/d/1jitup-4jbbFoG0NeH8cqt6HqMdsfd0WC/edit?usp=share_link&ouid=110553448349846752071&rtpof=true&sd=true)

## 1.安裝、載入套件&讀檔
```{r load, message=FALSE, warning=FALSE}
## 安裝套件
# install.packages(c("openxlsx", "qcc"))
## 載入套件
library(openxlsx)
library(qcc)

# 讀取檔案
file_path <- "/Users/bear/dev/R/Statistics/Data Files/Chapter7.xlsx" # 更改成您要讀取之xlsx的路徑
sheet_name_1 <- "Lux_Hotel" #這裡輸入您要讀取的sheet的名稱

# 使用read.xlsx函數讀取指定的工作表
lux.hotel.df <- read.xlsx(file_path, sheet = sheet_name_1)

print(lux.hotel.df)
```

## 2.生成隨機樣本
**（重現範例7.1）**

### 使用抽樣
#### A. 使用 sample() 函數
```{r sample}
# 從 20,000 名學生中隨機選擇 100 名學生
sample(1:20000, 100, replace = FALSE)
```
#### B. 使用 sample.int() 函數
```{r sample.int}
# 使用 replace = FALSE 因為我們希望不放回抽樣
sample.int(20000, 100, replace = FALSE)
```

### 從分布中生成樣本
#### A. 使用 runif() 函數從均勻分布中生成樣本
```{r runif()}
values <- runif(100, 1, 20000)
values
```
#### B. 將生成的值四捨五入到整數，獲得隨機整數樣本
```{r random}
round(values, 0)
```

## 3.構建 x̄ 圖
### A. 從 lux.hotel.df 數據文件中提取等待時間的列
```{r lux.hotel.df}
wait.times <- lux.hotel.df[, 3:6]
head(wait.times)
```
### B. 使用 qcc 函數創建 x̄ 圖
```{r graph, message=FALSE, warning=FALSE}
# 創建 x̄ 圖
qcc(wait.times, type = "xbar", center = 60, std.dev = 30, nsigmas = 3)
```

# Chapter 8

Chapter8.xlsx [下載點](https://docs.google.com/spreadsheets/d/1irH4-_QJqi5AL4mJRuc-se3b9fUuP9fa/edit?usp=share_link&ouid=110553448349846752071&rtpof=true&sd=true)

## 1.安裝、載入套件&讀檔
```{r ch8-1, message=FALSE, warning=FALSE}
# 安裝套件
# install.packages(c("openxlsx", "BSDA"))

# 載入套件
library(openxlsx)
library(BSDA)

# 讀取檔案
file_path <- "/Users/bear/dev/R/Statistics/Data Files/Chapter8.xlsx" # 更改成您要讀取之xlsx的路徑
sheet_name_1 <- "Hockey_Pucks" #這裡輸入您要讀取的sheet的名稱
sheet_name_2 <- "Lottery" #這裡輸入您要讀取的sheet的名稱

# 使用read.xlsx函數讀取指定的工作表
hockey.pucks.df <- read.xlsx(file_path, sheet = sheet_name_1)
lottery.df <- read.xlsx(file_path, sheet = sheet_name_2)

```

```{r ch8-2, message=FALSE, warning=FALSE}
# 用head() 函數用於查看資料的前幾行，默認值為6 行
head(hockey.pucks.df)
```

```{r ch8-3, message=FALSE, warning=FALSE}
# 調整查看的行數為前7行
head(lottery.df, 7)
```

### 對dataframe使用summary()函數

```{r 8-4}
summary(hockey.pucks.df)
```

```{r 8-5}
summary(lottery.df)
```

## 2. σ 已知時， 估計 μ
```{r 8-6, message=FALSE, warning=FALSE}
# 使用 hockey.pucks.df 數據文件來說明如何在已知 σ 的情況下估計 μ 的方法
# 使用 BSDA 包中的 z.test() 函數
# 將總體標準差 sigma.x 設置為 7.5，將信賴區間 conf.level 設置為 0.92

# 執行 z 檢驗
z.test(hockey.pucks.df[, "Weight"], sigma.x = 7.5, conf.level = 0.92)
```

## 3. σ 未知時， 估計 μ
```{r 8-7, message=FALSE, warning=FALSE}
# 使用 lottery.df 數據文件來說明如何在未知 σ 的情況下估計 μ 的方法
# 使用 BSDA 包中的 t.test() 函數
# 信賴區間 conf.level 的默認值為 0.95，但為了讓程式碼更清楚，在這裡仍然明確寫入程式碼中

# 執行 z 檢驗
t.test(lottery.df[, "Expenditures"], conf.level = 0.95)
```

## 4.估計 p
**使用範例8.7來說明如何估計 p**<br>

### A. 計算樣本比例
```{r 8-8A, message=FALSE, warning=FALSE}
# 設定成功次數 successes 為 7，試驗次數 trials 為 25，然後通過將 successes 除以 trials 來獲得樣本比例
successes <- 7
trials <- 25
pbar <- successes / trials
```

### B. 計算臨界值和誤差範圍
```{r 8-8B, message=FALSE, warning=FALSE}
# 使用 qnorm() 函數來找到臨界值 z
# 由於我們希望信賴區間為 90%，因此 α = 1 − 0.90 =0.10，我們使用 α/2 = 0.05
z <- -qnorm(0.05)
# 計算誤差範圍
margin.of.error <- z * sqrt(pbar * (1 - pbar) / trials)
```

### C. 計算信賴區間
```{r 8-8C, message=FALSE, warning=FALSE}
# 通過從樣本比例中加上和減去誤差範圍來找到信賴區間
conf.interval <- c(pbar - margin.of.error, pbar + margin.of.error)
conf.interval
```

# Chapter 9

Chapter9.xlsx [下載點](https://docs.google.com/spreadsheets/d/1KyHUSv7p4YvgKpVaQGBZrQhVcQZd0Xyh/edit?usp=share_link&ouid=110553448349846752071&rtpof=true&sd=true)

## 1.安裝、載入套件&讀檔
```{r ch9-1, message=FALSE, warning=FALSE}
# 安裝套件
# install.packages(c("openxlsx", "BSDA"))

# 載入套件
library(openxlsx)
library(BSDA)

# 讀取檔案
file_path <- "/Users/bear/dev/R/Statistics/Data Files/Chapter9.xlsx" # 更改成您要讀取之xlsx的路徑
sheet_name_1 <- "Debit_Spending" #這裡輸入您要讀取的sheet的名稱
sheet_name_2 <- "MI_Life" #這裡輸入您要讀取的sheet的名稱

# 使用read.xlsx函數讀取指定的工作表
debit.spending.df <- read.xlsx(file_path, sheet = sheet_name_1)
mi.life.expectancy.df <- read.xlsx(file_path, sheet = sheet_name_2)
```

### 對dataframe使用summary()函數

```{r 9-2}
summary(debit.spending.df)
```

```{r 9-3}
summary(mi.life.expectancy.df)
```

## 2. σ 已知時， 檢驗 μ
```{r 9-4, message=FALSE, warning=FALSE}
# 使用 debit.spending.df 數據文件來說明如何在已知 σ 的情況下檢驗 μ 的方法
# 使用 BSDA 包中的 z.test() 函數
# 因為對立假設是 H_A : μ < 8000，所以我們設置 μ = 8000 並將 alternative 選項設置為 "less"
# 將標準差 sigma.x 設置為 500

# 執行 z 檢驗
z.test(debit.spending.df[, "Spending"], mu = 8000, sigma.x = 500, alternative = "less")
```

## 3. σ 未知時， 檢驗 μ
```{r 9-5, message=FALSE, warning=FALSE}
# 使用 mi.life.expectancy.df 數據文件來說明如何在未知 σ 的情況下估計 μ 的方法
# 使用 BSDA 包中的 t.test() 函數
# 因為對立假設是 H_A : μ < 81.48，所以我們設置 μ = 81.48 並將 alternative 選項設置為 "less"

# 執行 t 檢驗
t.test(mi.life.expectancy.df[, "Age"], mu = 81.48, alternative = "less")
```

## 4.檢驗 p
**使用範例9.14來說明如何檢驗 p**<br>

### A. 計算樣本比例
```{r 9-6A, message=FALSE, warning=FALSE}
# 設定成功次數 successes 為 67，試驗次數 trials 為 180，然後通過將 successes 除以 trials 來獲得樣本比例
successes <- 67
trials <- 180
pbar <- successes / trials
```

### B. 計算樣本 z 統計量

使用公式計算 z 統計量：
![公式1](/Users/bear/dev/R/Statistics/zfor.png "統計量")
```{r 9-6B, message=FALSE, warning=FALSE}
# p=0.40 是在對立假設中的比例
z.statistic <- (pbar - 0.40) / sqrt(0.40 * (1 - 0.40) / trials)
```

### C. 計算 p 值
```{r 9-6C, message=FALSE, warning=FALSE}
# 使用 pnorm() 函數來計算與樣本 z 統計量相關的 p 值
# 由於對立假設是 HA : p<0.40，因此需要計算左尾 p 值
p.value <- pnorm(z.statistic)
p.value
```

# Chapter 10

Chapter10.xlsx [下載點](https://docs.google.com/spreadsheets/d/1McirZ6yGPMRtXTL0bSDElsu5fHRfaMau/edit?usp=share_link&ouid=110553448349846752071&rtpof=true&sd=true)

## 1.安裝、載入套件&讀檔
```{r 10-1}
library(openxlsx)
# 讀取檔案
file_path <- "/Users/bear/dev/R/Statistics/Data Files/Chapter10.xlsx" # 更改成您要讀取之xlsx的路徑
sheet_name_1 <- "Gold_Oil" #這裡輸入您要讀取的sheet的名稱
sheet_name_2 <- "Food_Calories" #這裡輸入您要讀取的sheet的名稱

# 使用read.xlsx函數讀取指定的工作表
gold.oil.df <- read.xlsx(file_path, sheet = sheet_name_1)
food.calories.df <- read.xlsx(file_path, sheet = sheet_name_2)
```

```{r 10-2}
summary(gold.oil.df)
```

```{r 10-3}
summary(food.calories.df)
```

## 2.測試 μ1 - μ2 的方法


#### 1.簡介
我們的目標是檢驗兩個獨立樣本的均值差異是否為零。具體來說，我們的零假設 (H0) 是 μ1 - μ2 = 0，而對立假設 (HA) 是 μ1 - μ2 ≠ 0。這表示我們希望檢查 Gold 和 Oil 兩個變數的均值是否存在顯著差異。

#### 2.使用 t.test() 函數
在 R 語言中，我們可以使用 t.test() 函數來進行這個檢驗。此函數會進行雙尾 t 檢驗，假設樣本獨立且方差不相等（這是 t.test() 函數的預設設置）。<br>

#### 3.程式碼與程式碼解釋
gold.oil.df[, "Gold"]：選取 gold.oil.df 數據框中的 Gold 列。<br>
gold.oil.df[, "Oil"]：選取 gold.oil.df 數據框中的 Oil 列。<br>
這段代碼會比較 Gold 和 Oil 兩組數據的均值，進行雙尾 t 檢驗。<br>

```{r 10-4}
# 範例 10.4
t.test(gold.oil.df[, "Gold"], gold.oil.df[, "Oil"])
```

#### 4.結果解讀
運行這段程式碼後，R 會輸出 t 檢驗的結果，包括 t 值、p 值以及均值的信賴區間等。根據 p 值，我們可以判斷是否拒絕零假設。若 p 值小於顯著性水平（例如 0.05），則我們可以拒絕零假設，認為兩組數據的均值存在顯著差異。<br>

## 2.測試 μ_0 的方法


#### 1.簡介
我們使用範例 10.8 和 food.calories.df 數據文件來演示如何測試 μ_0。以下是步驟和 R 語言程式碼：<br>
我們的目標是檢驗兩組相關樣本（Before 和 After）之間的均值差異是否大於零。具體來說，我們的零假設 (H0) 是 μ_0 ≤ 0，而對立假設 (HA) 是 μ_0 > 0。這表示我們希望檢查 After 階段的均值是否顯著高於 Before 階段的均值。<br>

#### 2.使用 t.test() 函數

在 R 語言中，我們可以使用 t.test() 函數來進行配對樣本 t 檢驗。由於我們要進行單尾檢驗（右尾檢驗），並且樣本是配對的，我們需要設置以下參數：<br>

paired = TRUE：表示進行配對樣本檢驗。<br>
alternative = "greater"：表示進行右尾檢驗，即檢驗均值差是否大於零。<br>

#### 3.程式碼與程式碼解釋
food.calories.df[, "Before"]：選取 food.calories.df 數據框中的 Before 列。<br>
food.calories.df[, "After"]：選取 food.calories.df 數據框中的 After 列。<br>
paired = TRUE：指定這是一個配對樣本檢驗。<br>
alternative = "greater"：指定進行右尾檢驗，即檢驗均值差是否大於零。<br>

```{r 10-5}
# 範例 10.8
t.test(food.calories.df[, "Before"], food.calories.df[, "After"], paired = TRUE, alternative = "greater")
```

#### 4.結果解讀
根據 p 值（遠小於顯著性水平 0.05），我們可以拒絕零假設，認為 After 階段的均值顯著高於 Before 階段的均值。<br>

# Chapter 11

Chapter11.xlsx [下載點](https://docs.google.com/spreadsheets/d/1BK8N8Ghh0gokco88COP-PzTWVTNFWP1-/edit?usp=share_link&ouid=110553448349846752071&rtpof=true&sd=true)

## 1.安裝、載入套件&讀檔
```{r 11-1}
library(openxlsx)
library(EnvStats)
# 讀取檔案
file_path <- "/Users/bear/dev/R/Statistics/Data Files/Chapter11.xlsx" # 更改成您要讀取之xlsx的路徑
sheet_name_1 <- "Fund_Returns" #這裡輸入您要讀取的sheet的名稱

# 使用read.xlsx函數讀取指定的工作表
fund.returns.df <- read.xlsx(file_path, sheet = sheet_name_1)
summary(fund.returns.df)
```

## 2.信賴區間計算 σ²

使用 varTest() 函數來計算方差的置信區間：
```{r 11-2}
result <- varTest(fund.returns.df[, "Metals"])
print(result)
```

## 3.檢驗 σ²

使用範例 11.4 和 fund.returns.df 數據文件中的 "Income" 變量來進行方差檢驗。我們的假設檢驗形式如下：<br/>

零假設 (H0): σ² = 72.25<br/>
對立假設 (HA): σ² ≠ 72.25<br/>

```{r 11-3}
result <- varTest(fund.returns.df[, "Income"], sigma.squared = 72.25)
print(result)
```

## 4.方差比值的信賴區間計算
我們使用範例 11.6 和 fund.returns.df 數據文件來構造兩個人口方差比值的置信區間。以下步驟詳細介紹了如何使用 R 來完成這個計算。<br>
```{r 11-4}
# 計算樣本方差比值
prop.var <- 182.25 / 457.96

# 計算自由度
df1 <- 11 - 1
df2 <- 16 - 1

# 計算信賴區間的下限
lower.bound <- prop.var / qf(0.975, df1, df2)

# 計算信賴區間的上限
upper.bound <- prop.var * qf(0.975, df2, df1)

# 顯示結果
print(lower.bound)
print(upper.bound)

```

## 5.方差比值檢驗
我們使用範例 11.8 和 fund.returns.df 數據文件來進行方差比值的假設檢驗。具體來說，我們將檢驗以下假設：
![假設](/Users/bear/dev/R/Statistics/截圖 2024-08-15 晚上11.34.07.png "假設")

#### A. 計算檢驗統計量
```{r 11-5}
# 計算樣本 F 統計量
sample.F <- var(fund.returns.df[,"Metals"]) / var(fund.returns.df[,"Income"])

# 顯示樣本 F 統計量
print(sample.F)
```

#### B.計算 p 值
```{r 11-6}
# 計算 p 值
pvalue <- 2 * pf(sample.F, 9, 9, lower.tail = FALSE)

# 顯示 p 值
print(pvalue)

```

# 參考資料

**Textbook**<br>
*Jaggia, S., & Kelly, A. (2019). Business statistics: Communicating with numbers (3th ed.). McGraw-Hill Education. *